# 移动端左侧栏抽拉逻辑开发文档

---

## 1. 需求与目标说明

- 实现移动端左侧栏（抽屉）可全屏任意位置拖拽，跟手滑动，支持悬停、反悔。
- 侧栏展开时主内容区有遮罩，点击遮罩可收回侧栏。
- 拖拽松手后自动吸附到展开/收起状态，动画流畅。
- 拖动时禁止页面滚动，提升沉浸感。
- 兼容 iOS/Android，保证高性能和极简体验。

---

## 2. 结构设计

### HTML 结构

```html
<div class="app-container">
    <div class="notes-list-panel drawer-collapsed animate__animated animate__fadeInLeft">
        <!-- 侧栏内容 -->
    </div>
    <div class="drawer-mask"></div> <!-- 遮罩层，初始隐藏 -->
    <div class="main-content-wrapper">
        <!-- 主内容区 -->
    </div>
</div>
```

- `.notes-list-panel`：左侧抽屉侧栏。
- `.drawer-mask`：遮罩层，侧栏展开时显示。
- `.main-content-wrapper`：主内容区。

---

## 3. 样式设计

### 侧栏样式

```css
.notes-list-panel {
  position: fixed;
  left: 0; top: 0; bottom: 0;
  width: 80vw; max-width: 320px;
  z-index: 10;
  background: var(--sidebar-bg);
  box-shadow: var(--shadow-lg);
  transform: translateX(-100%);
  transition: transform 0.28s cubic-bezier(0.4,1.4,.6,1);
}
.notes-list-panel:not(.drawer-collapsed) {
  transform: translateX(0);
}
```

### 遮罩层样式

```css
.drawer-mask {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.18);
  z-index: 9;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s;
}
.notes-list-panel:not(.drawer-collapsed) ~ .drawer-mask {
  opacity: 1;
  pointer-events: auto;
}
```

---

## 4. JS 逻辑分步说明

### 步骤一：基础拖拽逻辑
- 监听 `touchstart`、`touchmove`、`touchend` 事件。
- 记录手指起点，`touchmove` 时计算偏移量。
- 用 `transform: translateX(...)` 实时移动侧栏，跟随手指。

### 步骤二：松手后自动判断
- `touchend` 时，根据拖动距离/速度判断是展开还是收回。
- 用 `transition` 平滑过渡到最终状态。

### 步骤三：与 drawer-collapsed 状态联动
- 拖拽到收回/展开后，自动加/去 `.drawer-collapsed` 类，保证和原有逻辑兼容。

### 步骤四：动画与性能优化
- 拖动时关闭 transition，松手后再加 transition，避免“跟手”时卡顿。
- 只用 transform，不操作 left/right/width，保证高性能。

### 步骤五：细节与体验优化
- 限制拖动范围，防止拖出屏幕。
- 拖动时禁止页面滚动（`e.preventDefault()`，或 `touch-action: none`）。
- 拖拽时动态调整遮罩透明度（可选）。
- **注意：拖动过程中无需响应遮罩点击，只有侧栏完全展开且未拖动时，点击遮罩才会收回侧栏。**

---

## 5. 体验优化建议
- 拖拽时主内容区和遮罩层的透明度可随侧栏展开程度动态变化。
- 拖拽时彻底阻止 body/主内容区滚动，防止“穿透”到页面底层。
- 兼容 iOS/Android，使用 `passive: false` 监听 touchmove。
- 允许“悬停”或“反悔”体验（可选）。
- **遮罩点击收回仅在侧栏完全展开且未拖动时生效，拖动过程中无需处理遮罩点击。**

---

## 6. 关键代码片段示例

### 拖拽与吸附核心 JS 逻辑

```js
(function() {
  function isMobile() { return window.innerWidth <= 768; }
  const sidebar = document.querySelector('.notes-list-panel');
  const mask = document.querySelector('.drawer-mask');
  if (!sidebar || !mask) return;
  let dragging = false, startX = 0, currentX = 0, lastTranslate = 0, moved = false;
  const DRAG_THRESHOLD = 20;

  function getSidebarWidth() { return sidebar.offsetWidth || 320; }
  function setSidebarTranslate(x) {
    sidebar.style.transition = 'none';
    sidebar.style.transform = `translateX(${x}px)`;
  }
  function resetSidebarTransition() {
    sidebar.style.transition = '';
    sidebar.style.transform = '';
  }

  document.addEventListener('touchstart', function(e) {
    if (!isMobile() || e.touches.length !== 1) return;
    dragging = true;
    startX = e.touches[0].clientX;
    currentX = startX;
    moved = false;
    lastTranslate = sidebar.classList.contains('drawer-collapsed') ? -getSidebarWidth() : 0;
    sidebar.style.willChange = 'transform';
  }, { passive: true });

  document.addEventListener('touchmove', function(e) {
    if (!dragging || !isMobile()) return;
    const moveX = e.touches[0].clientX;
    let deltaX = moveX - startX;
    if (!moved && Math.abs(deltaX) > DRAG_THRESHOLD) {
      moved = true;
      sidebar.classList.remove('drawer-collapsed');
    }
    if (moved) {
      let targetTranslate = lastTranslate + deltaX;
      const sidebarWidth = getSidebarWidth();
      targetTranslate = Math.min(0, Math.max(-sidebarWidth, targetTranslate));
      setSidebarTranslate(targetTranslate);
      e.preventDefault();
    }
  }, { passive: false });

  document.addEventListener('touchend', function(e) {
    if (!dragging || !isMobile()) return;
    dragging = false;
    sidebar.style.willChange = '';
    if (!moved) { resetSidebarTransition(); return; }
    const sidebarWidth = getSidebarWidth();
    const style = window.getComputedStyle(sidebar);
    const matrix = new WebKitCSSMatrix(style.transform);
    const finalX = matrix.m41;
    if (finalX > -sidebarWidth / 2) {
      sidebar.classList.remove('drawer-collapsed');
    } else {
      sidebar.classList.add('drawer-collapsed');
    }
    sidebar.style.transition = 'transform 0.28s cubic-bezier(0.4,1.4,.6,1)';
    sidebar.style.transform = '';
    setTimeout(() => { sidebar.style.transition = ''; }, 300);
  }, { passive: true });

  // 遮罩点击收回（仅在侧栏完全展开且未拖动时生效）
  mask.addEventListener('click', function() {
    sidebar.classList.add('drawer-collapsed');
  });
})();
```

--- 