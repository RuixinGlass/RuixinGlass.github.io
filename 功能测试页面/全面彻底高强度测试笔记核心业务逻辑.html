<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ - ç»ˆæå‹åŠ›æµ‹è¯•</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Inter', 'PingFang SC', sans-serif; margin: 0; padding: 20px; background: #fcfcfa; color: #23272e; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 20px 30px; border-radius: 12px; box-shadow: 0 4px 24px 0 rgba(60, 60, 60, 0.07); }
        h1 { font-size: 2em; color: #6a7ba2; border-bottom: 2px solid #e5e5e0; padding-bottom: 0.5em; margin-bottom: 1em; }
        .test-controls button { background: #6a7ba2; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: 500; transition: all 0.2s; margin-right: 10px; }
        .test-controls button:hover { background: #4b5c8a; transform: translateY(-2px); }
        .test-controls button.danger { background: #e57373; }
        .test-controls button.danger:hover { background: #d32f2f; }
        .log-area { background: #2d3436; color: #dfe6e9; padding: 20px; border-radius: 8px; font-family: 'JetBrains Mono', monospace; font-size: 14px; line-height: 1.6; max-height: 500px; overflow-y: auto; margin-top: 20px; white-space: pre-wrap; }
        .status { padding: 15px; border-radius: 8px; margin: 10px 0; font-weight: 500; border-left: 5px solid; }
        .status.success { background: #e8f5e9; color: #2e7d32; border-color: #4caf50; }
        .status.error { background: #ffebee; color: #c62828; border-color: #f44336; }
        .status.info { background: #e3f2fd; color: #1976d2; border-color: #2196f3; }
        .status.summary { background: #f3e8ff; color: #6a1b9a; border-color: #8e24aa; font-size: 1.1em; text-align: center; }
        .log-area .log-success { color: #55efc4; }
        .log-area .log-error { color: #ff7675; font-weight: bold; }
        .log-area .log-info { color: #74b9ff; }
        .log-area .log-step { color: #fdcb6e; font-weight: bold; margin-top: 10px; display: block; }
    </style>
</head>
<body>
    <div class="container">
        <h1><i class="fas fa-vial"></i> æ ¸å¿ƒé€»è¾‘ç»ˆæå‹åŠ›æµ‹è¯•</h1>
        
        <div class="test-controls">
            <button id="startTestBtn" onclick="runAllTests()"><i class="fas fa-play-circle"></i> å¼€å§‹ç»ˆæå‹åŠ›æµ‹è¯•</button>
            <button class="danger" onclick="clearLogsAndState()"><i class="fas fa-trash-alt"></i> æ¸…ç©ºæ—¥å¿—å’ŒçŠ¶æ€</button>
        </div>

        <div id="testResults">
            <div class="status info">å‡†å¤‡å°±ç»ªã€‚ç‚¹å‡»æŒ‰é’®å¼€å§‹æµ‹è¯•...</div>
        </div>

        <div id="logArea" class="log-area"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>

    <script>
        // ========== æµ‹è¯•ç¯å¢ƒæ­å»º ==========
        const logArea = document.getElementById('logArea');
        const testResults = document.getElementById('testResults');
        let testCounter = 0;

        function log(message, type = 'info') {
            const typeClass = `log-${type}`;
            logArea.innerHTML += `<span class="${typeClass}">${message}</span>\n`;
            logArea.scrollTop = logArea.scrollHeight;
            console[type === 'error' ? 'error' : 'log'](message);
        }

        function clearLogsAndState() {
            logArea.innerHTML = '';
            testResults.innerHTML = '<div class="status info">å‡†å¤‡å°±ç»ªã€‚ç‚¹å‡»æŒ‰é’®å¼€å§‹æµ‹è¯•...</div>';
            testCounter = 0;
        }

        async function runTest(title, testFn) {
            testCounter++;
            log(`\n<span class="log-step">====== (æµ‹è¯• ${testCounter}) ${title} ======</span>`);
            try {
                const result = await testFn();
                const message = result || 'æ“ä½œæˆåŠŸ';
                log(`âœ… é€šè¿‡: ${message}`, 'success');
                return true;
            } catch (error) {
                log(`âŒ å¤±è´¥: ${error.message}`, 'error');
                console.error(error);
                return false;
            }
        }

        // ========== æ¨¡æ‹Ÿæ ¸å¿ƒåº”ç”¨é€»è¾‘ ==========
        let mockNotesData = {};
        let mockSessionState = new Map();
        let mockCmEditor = null;

        class MockSessionState {
            constructor() { this.mode = 'edit'; this.history = { undo: 1, redo: 0 }; }
            restoreToCodeMirror(editor) { editor.history = this.history; }
        }

        class MockCodeMirror {
            constructor(value) { this.value = value; this.history = { undo: 0, redo: 0 }; this.clean = true; }
            getValue() { return this.value; }
            setValue(val) { this.value = val; this.clean = false; }
            isClean() { return this.clean; }
            markClean() { this.clean = true; }
            getHistory() { return { ...this.history }; }
            setHistory(h) { this.history = { ...h }; }
            undo() { this.history.undo--; this.history.redo++; }
        }

        async function mockSaveToLocalStorage(data) {
            return new Promise(resolve => setTimeout(() => {
                mockNotesData = JSON.parse(JSON.stringify(data)); // Deep copy
                resolve();
            }, 10)); // æ¨¡æ‹Ÿå¼‚æ­¥IO
        }
        
        async function mockSaveVersion() {
            if (!mockCmEditor || !mockNotesData.currentNoteId) throw new Error("ä¿å­˜ç‰ˆæœ¬å‰çŠ¶æ€æ— æ•ˆ");
            
            const note = mockNotesData.notes[mockNotesData.currentNoteId];
            note.content = mockCmEditor.getValue();
            if (!note.versions) note.versions = [];
            note.versions.push({ content: note.content, timestamp: Date.now() });

            await mockSaveToLocalStorage(mockNotesData);
            
            mockCmEditor.markClean();
            mockSessionState.delete(mockNotesData.currentNoteId);
        }

        function assert(condition, message) {
            if (!condition) throw new Error(`æ–­è¨€å¤±è´¥: ${message}`);
        }

        // ========== ç»ˆæå‹åŠ›æµ‹è¯•è„šæœ¬ ==========
        async function runAllTests() {
            clearLogsAndState();
            log('ğŸš€ å¼€å§‹æ‰§è¡Œæ ¸å¿ƒé€»è¾‘ç»ˆæå‹åŠ›æµ‹è¯•...', 'info');
            document.getElementById('startTestBtn').disabled = true;
            let successCount = 0;
            const totalTests = 5;

            // --- æµ‹è¯• 1: æ™ºèƒ½ç‰ˆæœ¬åˆ›å»ºä¸æ’¤é”€ ---
            const test1_result = await runTest("æ™ºèƒ½ç‰ˆæœ¬åˆ›å»ºä¸æ’¤é”€", async () => {
                mockNotesData = { currentNoteId: 'note1', notes: { 'note1': { content: 'åˆå§‹å†…å®¹', versions: [] } } };
                mockCmEditor = new MockCodeMirror('åˆå§‹å†…å®¹');
                mockCmEditor.markClean();

                assert(mockCmEditor.isClean(), "åˆå§‹çŠ¶æ€åº”ä¸ºå¹²å‡€");
                
                mockCmEditor.setValue('å†…å®¹å·²ä¿®æ”¹');
                assert(!mockCmEditor.isClean(), "ä¿®æ”¹åçŠ¶æ€åº”ä¸ºè„");
                
                mockCmEditor.setValue('åˆå§‹å†…å®¹'); 
                mockCmEditor.markClean(); 
                assert(mockCmEditor.isClean(), "æ’¤é”€æ‰€æœ‰ä¿®æ”¹ååº”æ¢å¤å¹²å‡€çŠ¶æ€");
                
                return "è„çŠ¶æ€ä¸æ’¤é”€é€»è¾‘æ­£ç¡®";
            });
            if (test1_result) successCount++;
            
            // --- æµ‹è¯• 2: å®Œæ•´ä¼šè¯åˆ‡æ¢ä¸æ¢å¤æµç¨‹ ---
            const test2_result = await runTest("å®Œæ•´ä¼šè¯åˆ‡æ¢ä¸æ¢å¤æµç¨‹", async () => {
                mockNotesData = {
                    currentNoteId: 'noteA',
                    notes: {
                        'noteA': { content: 'ç¬”è®°Aå†…å®¹', versions: [] },
                        'noteB': { content: 'ç¬”è®°Bå†…å®¹', versions: [] }
                    }
                };
                mockSessionState.clear();
                mockCmEditor = new MockCodeMirror('ç¬”è®°Aå†…å®¹');
                mockCmEditor.setValue('ç¬”è®°Aè¢«ä¿®æ”¹äº†');
                mockCmEditor.undo();
                mockSessionState.set('noteA', new MockSessionState());
                await mockSaveToLocalStorage(mockNotesData);
                const noteA_session = mockSessionState.get('noteA');
                assert(noteA_session, "ç¬”è®°Açš„ä¼šè¯åº”å·²å­˜æ¡£");
                assert(noteA_session.mode === 'edit', "å­˜æ¡£æ¨¡å¼åº”ä¸ºedit");
                mockNotesData.currentNoteId = 'noteA';
                const restoredCmEditor = new MockCodeMirror(mockNotesData.notes['noteA'].content);
                noteA_session.restoreToCodeMirror(restoredCmEditor);
                assert(restoredCmEditor.history.undo > 0, "æ¢å¤çš„ç¼–è¾‘å™¨åº”åŒ…å«æ’¤é”€å†å²");
                mockCmEditor = restoredCmEditor;
                await mockSaveVersion();
                assert(mockNotesData.notes['noteA'].versions.length === 1, "åº”å·²åˆ›å»º1ä¸ªæ–°ç‰ˆæœ¬");
                assert(!mockSessionState.has('noteA'), "ä¿å­˜ç‰ˆæœ¬åï¼Œä¼šè¯å­˜æ¡£åº”è¢«æ¸…ç†");
                return "ä¼šè¯çš„å­˜æ¡£ã€æ¢å¤ã€æ¸…ç†æµç¨‹é—­ç¯æ­£ç¡®";
            });
            if (test2_result) successCount++;
            
            // --- æµ‹è¯• 3: é«˜å¹¶å‘é™é»˜ä¿å­˜ä¸ç‰ˆæœ¬åˆ›å»º ---
            const test3_result = await runTest("é«˜å¹¶å‘ä¿å­˜è¯·æ±‚", async () => {
                // ã€ä¿®å¤ã€‘ä¸ºæœ¬æµ‹è¯•è®¾ç½®ç‹¬ç«‹çš„åˆå§‹çŠ¶æ€
                mockNotesData = { currentNoteId: 'noteX', notes: { 'noteX': { content: 'å¹¶å‘æµ‹è¯•åˆå§‹å†…å®¹', versions: [] } } };

                const promises = [];
                for (let i = 0; i < 50; i++) {
                    // ç¡®ä¿æ¯æ¬¡å¹¶å‘ä¿å­˜éƒ½åŸºäºå®Œæ•´çš„notesDataç»“æ„
                    const tempData = JSON.parse(JSON.stringify(mockNotesData));
                    tempData.notes['noteX'].content = `å¹¶å‘å†™å…¥ ${i}`;
                    promises.push(mockSaveToLocalStorage(tempData));
                }
                await Promise.all(promises);
                assert(mockNotesData.notes['noteX'].content === 'å¹¶å‘å†™å…¥ 49', "æœ€åä¸€æ¬¡å†™å…¥åº”è¦†ç›–ä¹‹å‰çš„å†…å®¹");

                // ã€ä¿®å¤ã€‘åœ¨è°ƒç”¨saveVersionå‰ï¼Œç¡®ä¿mockCmEditorå’ŒcurrentNoteIdéƒ½å·²å°±ç»ª
                mockNotesData.currentNoteId = 'noteX';
                mockCmEditor = new MockCodeMirror('æœ€ç»ˆç‰ˆæœ¬');
                await mockSaveVersion();
                assert(mockNotesData.notes['noteX'].versions.length === 1, "é«˜å¹¶å‘åä»èƒ½æˆåŠŸåˆ›å»ºç‰ˆæœ¬");
                
                return "é«˜å¹¶å‘å†™å…¥æœªé€ æˆæ•°æ®æˆ–çŠ¶æ€æŸå";
            });
            if (test3_result) successCount++;

            // --- æµ‹è¯• 4: é•¿ç¯‡ç¬”è®°çš„è„çŠ¶æ€æ£€æµ‹ ---
            const test4_result = await runTest("é•¿ç¯‡ç¬”è®°çš„è„çŠ¶æ€æ£€æµ‹", async () => {
                const longText = 'a'.repeat(50000);
                mockCmEditor = new MockCodeMirror(longText);
                mockCmEditor.markClean();
                const modifiedLongText = longText.slice(0, 49999) + 'b';
                mockCmEditor.setValue(modifiedLongText);
                assert(!mockCmEditor.isClean(), "å³ä½¿æ˜¯é•¿æ–‡æœ¬çš„å¾®å°æ”¹åŠ¨ä¹Ÿåº”è¢«æ£€æµ‹ä¸ºè„");
                return "é•¿æ–‡æœ¬ä¿®æ”¹æ£€æµ‹æˆåŠŸï¼Œé¿å…äº†æ—§çš„bug";
            });
            if (test4_result) successCount++;

            // --- æµ‹è¯• 5: è¾¹ç•Œæƒ…å†µï¼šç©ºç¬”è®°çš„ç¼–è¾‘ä¸ä¿å­˜ ---
            const test5_result = await runTest("è¾¹ç•Œæƒ…å†µï¼šç©ºç¬”è®°çš„ç¼–è¾‘ä¸ä¿å­˜", async () => {
                mockNotesData = { currentNoteId: 'emptyNote', notes: { 'emptyNote': { content: '', versions: [] } } };
                mockCmEditor = new MockCodeMirror('');
                mockCmEditor.markClean();
                mockCmEditor.setValue('æ–°å¢å†…å®¹');
                await mockSaveVersion();
                assert(mockNotesData.notes['emptyNote'].versions.length === 1, "ç©ºç¬”è®°ç¼–è¾‘ååº”èƒ½æˆåŠŸä¿å­˜ç‰ˆæœ¬");
                assert(mockNotesData.notes['emptyNote'].content === 'æ–°å¢å†…å®¹', "ç©ºç¬”è®°å†…å®¹åº”è¢«æ­£ç¡®æ›´æ–°");
                return "ç©ºç¬”è®°çš„ç¼–è¾‘å’Œä¿å­˜é€»è¾‘æ­£å¸¸";
            });
            if (test5_result) successCount++;

            // --- æ€»ç»“ ---
            log('\n<span class="log-step">====== æµ‹è¯•æ€»ç»“ ======</span>');
            const summaryClass = successCount === totalTests ? 'success' : 'error';
            const summaryMessage = successCount === totalTests 
                ? `ğŸ‰ å…¨éƒ¨ ${totalTests} é¡¹æ ¸å¿ƒé€»è¾‘æµ‹è¯•é€šè¿‡ï¼ç³»ç»Ÿéå¸¸ç¨³å®šï¼`
                : `ğŸ”¥ ${totalTests - successCount} / ${totalTests} é¡¹æµ‹è¯•å¤±è´¥ã€‚è¯·æ£€æŸ¥æ—¥å¿—ã€‚`;
            
            testResults.innerHTML = `<div class="status summary ${summaryClass}">${summaryMessage}</div>`;
            document.getElementById('startTestBtn').disabled = false;
        }
    </script>
</body>
</html>